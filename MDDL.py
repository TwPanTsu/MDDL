from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import io
import time
import numpy as np
#import picamera
import cv2
#import tensorflow as tf
from PIL import Image
from tflite_runtime.interpreter import Interpreter
#import GPIO and time
import RPi.GPIO as GPIO # Import Raspberry Pi GPIO library
import time
#import SMTP
import smtplib

GPIO.setwarnings(False) # Ignore warning for now
GPIO.setmode(GPIO.BOARD) # Use physical pin numbering
GPIO.setup(10, GPIO.IN, pull_up_down=GPIO.PUD_DOWN) # Set pin 10 to be an input pin and set initial value to be pulled low (off)
GPIO.setup(11, GPIO.OUT)
GPIO.setup(13, GPIO.OUT)
GPIO.setup(15, GPIO.OUT)

def load_labels(path):
	with open(path, 'r') as f:
		return {i: line.strip() for i, line in enumerate(f.readlines())}


def set_input_tensor(interpreter, image):
	tensor_index = interpreter.get_input_details()[0]['index']
	input_tensor = interpreter.tensor(tensor_index)()[0]
	input_tensor[:, :] = image


def classify_image(interpreter, image, top_k=1):
	"""Returns a sorted array of classification results."""
	set_input_tensor(interpreter, image)
	interpreter.invoke()
	output_details = interpreter.get_output_details()[0]
	output = np.squeeze(interpreter.get_tensor(output_details['index']))

	# If the model is quantized (uint8 data), then dequantize the results
	if (output_details['dtype'] == np.uint8):
		scale, zero_point = output_details['quantization']
		output = scale * (output - zero_point)

	ordered = np.argpartition(-output, top_k)
	return [(i, output[i]) for i in ordered[:top_k]]


def main():
	parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
	parser.add_argument(      '--model', help='File path of .tflite file.', required=True)
	parser.add_argument(      '--labels', help='File path of labels file.', required=True)
	args = parser.parse_args()
	labels = load_labels(args.labels)

	#interpreter = tf.lite.Interpreter(args.model)
	interpreter = Interpreter(args.model)

	interpreter.allocate_tensors()
	_, height, width, _ = interpreter.get_input_details()[0]['shape']
	op=0
	zUser = 'ncustudent00@gmail.com'
	zPass = 'au4a83123'
	zTo = 'supermice0000@gmail.com'
	zFrom = zUser
	zSubject = 'Mask Doorlock System'
	zHeader = 'To: ' + zTo + '\n' + 'From: ' + zFrom + '\n' + 'Subject: ' + zSubject

	try:
		while True: # Run forever
			if(op==0):
				print("welcome to mask doorlock system, push the button to grant access")
				op=1
			GPIO.output(11,1)
			GPIO.output(15,1)
			GPIO.output(13,0)
			if GPIO.input(10) == GPIO.HIGH:
				print("Button was pushed! after 5 seconds ,camera will take 10 image!")
				#with picamera.PiCamera(resolution=(640, 480), framerate=30) as camera:
				#camera.start_preview()
				cap = cv2.VideoCapture(0)
				cap.set(cv2.CAP_PROP_FRAME_WIDTH,1920)
				cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
				time.sleep(5)
				key_detect=0
				times=1
				sum=0
				op=0
				while (key_detect==0):
					ret,image_src =cap.read()
					frame_width=image_src.shape[1]
					frame_height=image_src.shape[0]
					cut_d=int((frame_width-frame_height)/2)
					crop_img=image_src[0:frame_height,cut_d:(cut_d+frame_height)]
					image=cv2.resize(crop_img,(224,224),interpolation=cv2.INTER_AREA)
					start_time = time.time()
					if (times<11):
						results = classify_image(interpreter, image)
						elapsed_ms = (time.time() - start_time) * 1000
						label_id, prob = results[0]
						print(labels[label_id],prob)
						cv2.putText(crop_img,labels[label_id] + " " + str(round(prob,3)), (5,30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,0,255), 1, cv2.LINE_AA)
						sum=sum+label_id
						times=times+1
					if (times==11):
						key_detect = 1
					cv2.imshow('Detecting....',crop_img)
				cap.release()
				cv2.destroyAllWindows()
				if (sum<6):
					print(sum)
					print("no face detected, access denied")
					GPIO.output(15,1)
					GPIO.output(13,0)
					zBody = 'Response request: No\nLock Status: Close\nDetect Status: No Face Detected\nThis mail is auto-generated by system\nPlease do not reply!'
					oSmtp = smtplib.SMTP('smtp.gmail.com',587)
					oSmtp.starttls()
					oSmtp.ehlo()
					oSmtp.login(zUser, zPass)
					oSmtp.sendmail(zFrom, zTo, zHeader + '\n\n' + zBody)
					oSmtp.quit()
				if (sum>5 and sum<16):
					print(sum)
					print("not wearing mask, wait for manager response")
					GPIO.output(15,1)
					GPIO.output(13,0)
					zBody = 'Response request: Yes\nLock Status: Close\nDetect Status: NO  Masked Face\nThis mail is auto-generated by system\nPlease do not reply!'
					oSmtp = smtplib.SMTP('smtp.gmail.com',587)
					oSmtp.starttls()
					oSmtp.ehlo()
					oSmtp.login(zUser, zPass)
					oSmtp.sendmail(zFrom, zTo, zHeader + '\n\n' + zBody)
					oSmtp.quit()
					while True:
						answer = input('you have no mask on, please wait for manager answer:[y/n]')
						if (answer is 'y'):
							print("access granted, do not forget wearing mask next time!")
							GPIO.output(13,1)
							GPIO.output(15,0)
							zBody = 'Response request: No\nLock Status: Open for 5 secons\nDetect Status: NO  Masked Face\nThis mail is auto-generated by system\nPlease do not reply!'
							oSmtp = smtplib.SMTP('smtp.gmail.com',587)
							oSmtp.starttls()
							oSmtp.ehlo()
							oSmtp.login(zUser, zPass)
							oSmtp.sendmail(zFrom, zTo, zHeader + '\n\n' + zBody)
							oSmtp.quit()
							break
						elif(answer is 'n'):
							print("access denied, do not forget wearing mask next time!")
							GPIO.output(13,0)
							GPIO.output(15,1)
							zBody = 'Response request: No\nLock Status: Close\nDetect Status: NO  Masked Face\nThis mail is auto-generated by system\nPlease do not reply!'
							oSmtp = smtplib.SMTP('smtp.gmail.com',587)
							oSmtp.starttls()
							oSmtp.ehlo()
							oSmtp.login(zUser, zPass)
							oSmtp.sendmail(zFrom, zTo, zHeader + '\n\n' + zBody)
							oSmtp.quit()
							break
				if (sum>15):
					print(sum)
					print("well done,access granted")
					GPIO.output(13,1)
					GPIO.output(15,0)
					zBody = 'Response request: No\nLock Status: Open for 5 seconds\nDetect Status: A Masked Face\nThis mail is auto-generated by system\nPlease do not reply!'
					oSmtp = smtplib.SMTP('smtp.gmail.com',587)
					oSmtp.starttls()
					oSmtp.ehlo()
					oSmtp.login(zUser, zPass)
					oSmtp.sendmail(zFrom, zTo, zHeader + '\n\n' + zBody)
					oSmtp.quit()
					time.sleep(5)
					GPIO.output(13,0)
					GPIO.output(15,1)
	finally:
		GPIO.cleanup()

if __name__ == '__main__':
  main()
